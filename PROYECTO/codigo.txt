// Casos de prueba SUPER SIMPLIFICADOS para el analizador semántico
// Intentando evitar errores de parsing de FLOAT_NUM y STRING_LITERAL.

// Declaraciones globales
int g_int1;
int g_int2;
float g_float1;
float g_float2;
string g_str1;
string g_str2;
bool g_bool1;
bool g_bool2;

// Funciones básicas
int sum(int a, int b) {
  return a; // Simplificado para asegurar parsing del cuerpo
}

float sum_f(float a, float b) {
  return a; // Simplificado
}

string concat_s(string a, string b) {
  return a; // Simplificado
}

bool logic_b(bool a, bool b) {
  return a; // Simplificado
}

void print_int(int val) {
  // print val; // El parser original podría no tener 'print ID;' sino 'print exp;'
  // Para asegurar el parsing, no hacemos nada o usamos un print(1) si es necesario.
  // La prueba de print(exp) se hará con cuidado.
}


main() {
  int l_int1;
  int l_int2;
  float l_float1;
  float l_float2;
  string l_str1;
  string l_str2;
  bool l_bool1;
  bool l_bool2;

  // Asignaciones simples entre variables del mismo tipo (después de ser declaradas)
  g_int1 = l_int1;       // int = int
  l_int2 = g_int1;       // int = int

  g_float1 = l_float1;   // float = float
  l_float2 = g_float1;   // float = float

  g_str1 = l_str1;       // string = string
  l_str2 = g_str1;       // string = string

  g_bool1 = l_bool1;     // bool = bool
  l_bool2 = g_bool1;     // bool = bool

  // Promoción int -> float
  l_float1 = l_int1;     // float = int (promoción)

  // Truncamiento float -> int
  l_int1 = l_float1;     // int = float (truncamiento)

  // Operaciones (entre variables locales para controlar tipos)
  l_int1 = l_int1 + l_int2;       // int = int + int
  l_float1 = l_float1 + l_float2; // float = float + float
  l_float1 = l_int1 + l_float1;   // float = int + float
  // l_str1 = l_str1 + l_str2;    // string = string + string (Si '+' para string es soportado)
                                  // Usar concat_s para asegurar la operación
  l_str1 = concat_s(l_str1, l_str2);

  l_bool1 = l_bool1 && l_bool2;   // bool = bool && bool


  // Llamadas a funciones
  l_int2 = sum(l_int1, g_int2);
  l_float2 = sum_f(l_float1, g_float2);
  l_str2 = concat_s(l_str1, g_str2);
  l_bool2 = logic_b(l_bool1, g_bool2);

  print_int(l_int1); // Prueba de print con variable

  // Pruebas de error (se deben agregar una por una para ver el error específico)
  // Descomentar la línea que se quiere probar:

  // Error de tipo en asignación:
  // l_int1 = l_str1;        // ERROR: int = string
  // l_float1 = l_bool1;     // ERROR: float = bool
  // l_str1 = l_int1;        // ERROR: string = int
  // l_bool1 = l_float1;     // ERROR: bool = float

  // Error de tipo en operación:
  // l_int1 = l_int1 + l_str1; // ERROR: int + string
  // l_float1 = l_float1 / l_bool1; // ERROR: float / bool

  // Error de tipo en argumentos de función:
  // l_int1 = sum(l_int1, l_str1); // ERROR: sum(int, string)

  // Error: Pasar menos argumentos
  // l_int1 = sum(l_int1);          // ERROR: sum(int)

  // Error: Pasar más argumentos
  // l_int1 = sum(l_int1, l_int2, l_int1); // ERROR: sum(int,int,int)

  // Error: Asignar resultado de función void
  // l_int1 = print_int(l_int2);   // ERROR: int = void
}
